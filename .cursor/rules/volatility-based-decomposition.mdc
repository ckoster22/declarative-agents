---
description: High level design
globs: 
alwaysApply: false
---
# Volatility-Based Decomposition Rules

## Rule: Identify Volatile Components
When analyzing code or designing a system:
- Look for components that are likely to change independently
- Consider external dependencies that might change (APIs, libraries, frameworks)
- Identify business rules that frequently change
- Look for components that might need different deployment schedules
- Consider components that might need different scaling strategies

## Rule: Separate Volatile Components
When implementing code:
- Create separate modules/classes for volatile components
- Use interfaces/abstract classes to define stable contracts
- Implement dependency injection for volatile dependencies
- Keep volatile components loosely coupled from stable ones
- Use configuration files for frequently changing values

## Rule: Handle External Dependencies
When dealing with external systems:
- Create adapter layers for external APIs
- Implement circuit breakers for unreliable services
- Use caching strategies for slow or unstable services
- Implement retry mechanisms with exponential backoff
- Create mock implementations for testing

## Rule: Business Rule Volatility
When implementing business rules:
- Separate business rules from core logic
- Use rule engines or configuration for frequently changing rules
- Implement business rules as plugins or modules
- Keep business rule validation separate from data processing
- Use feature flags for experimental or frequently changing features

## Rule: Data Access Volatility
When dealing with data access:
- Use repository pattern to abstract data access
- Implement separate data access layers for different data sources
- Use ORM configurations for database schema changes
- Keep data migration strategies separate from business logic
- Implement caching strategies for frequently accessed data

## Rule: UI/UX Volatility
When implementing user interfaces:
- Separate UI components from business logic
- Use component-based architecture for UI elements
- Implement responsive design patterns
- Keep styling separate from structure
- Use theme configurations for visual changes

## Rule: Configuration Volatility
When handling configuration:
- Externalize all configuration values
- Use environment-specific configuration files
- Implement configuration validation
- Use feature flags for runtime configuration
- Keep sensitive configuration secure

## Rule: Testing Volatile Components
When testing volatile components:
- Create separate test suites for volatile components
- Use mocking for external dependencies
- Implement integration tests for critical paths
- Use property-based testing for complex rules
- Keep test data separate from test logic